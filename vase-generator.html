<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PNG → Twist Vase Generator (Three.js r160+)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root{
      --sidebar-width: 380px;
      --sidebar-min: 280px;
      --sidebar-max: 720px;
      --accent: #7c3aed;
      --bg: #0b0c10;
      --panel: #121319;
      --panel-2: #191a22;
      --text: #e8e9ef;
      --muted: #9aa1aa;
      --good: #16a34a;
      --warn: #d97706;
      --bad:  #ef4444;
      --grid: #2a2d38;
    }
    *{ box-sizing: border-box }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--text); font:14px/1.35 system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }

    .layout{
      display:grid;
      grid-template-columns: var(--sidebar-width) 6px 1fr;
      grid-template-rows: 100%;
      height:100%;
      overflow:hidden;
    }
    aside{
      background:linear-gradient(180deg, var(--panel), var(--panel-2));
      border-right:1px solid #1e2130;
      overflow:auto;
      padding:12px 12px 18px 12px;
    }
    .splitter{
      cursor: col-resize;
      background: #1d2030;
      border-right: 1px solid #0f1018;
      border-left: 1px solid #0f1018;
    }
    main{ position:relative; }
    #viewport{ position:absolute; inset:0; }

    h2{
      margin: 8px 0 6px;
      font-size: 13px;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .row{
      display:flex; gap:8px; align-items:center; margin:6px 0;
    }
    .row > label{ flex:0 0 120px; color:var(--muted); font-size:12px; }
    .row > input[type="range"]{ flex:1 }
    input, select, button{
      background:#0f1018;
      color:var(--text);
      border:1px solid #26283a;
      padding:6px 8px;
      border-radius:8px;
      outline:none;
    }
    input[type="number"]{ width:100px }
    input[type="color"]{
      padding:0; height:32px; width:48px; border-radius:6px;
      border:1px solid #3a3d55;
      background:#000;
    }
    button{
      background: linear-gradient(180deg, #1a1c29, #141622);
      border:1px solid #2e3150;
      cursor:pointer;
      transition: box-shadow .15s ease;
    }
    button:hover{ box-shadow:0 0 0 2px rgba(124,58,237,.25) inset; }
    button.primary{
      background: linear-gradient(180deg, #6d28d9, #5b21b6);
      border-color:#7c3aed;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }
    .card{
      background:#0d0f17;
      border:1px solid #23263a;
      border-radius:12px;
      padding:10px;
    }
    .hint{ color:var(--muted); font-size:12px; }
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      background:#0f1220; border:1px solid #2f3350; color:#c3c6d4;
      border-radius:999px; padding:4px 8px; font-size:12px; margin:4px 6px 0 0;
    }

    .editor{
      background:#0b0d15;
      border:1px solid #2a2d40;
      border-radius:10px;
      position:relative;
      height:180px;
      cursor:crosshair;
      user-select:none;
      touch-action:none;
    }
    .legend{ display:flex; justify-content:space-between; margin-top:6px; color:var(--muted); font-size:11px; }
    .img-preview{
      display:grid; grid-template-columns: 1fr auto; align-items:center; gap:8px;
    }
    canvas.preview{
      width:100%; height:160px; object-fit:contain; background:#0a0c13; border:1px dashed #2b2e44; border-radius:8px;
    }
    .row-tight{ gap:6px }
    .two-col{
      display:grid; grid-template-columns: 1fr 1fr; gap:10px;
    }
    .stat{ color:#cbd5e1; font-size:12px }
    .stat b{ color:#e2e8f0 }
    .footer-actions{
      display:flex; gap:8px; justify-content:space-between; align-items:center; margin-top:8px;
      position:sticky; bottom:0; background:linear-gradient(180deg, rgba(13,15,23,.0), rgba(13,15,23,.8) 30%, rgba(13,15,23,1));
      padding-top:6px;
    }
    .env-note{ color:#8ab4ff; font-size:12px }

    /* small helper badges */
    .badge{
      display:inline-block; padding:2px 6px; font-size:11px; border:1px solid #3b3f5c; border-radius:6px; color:#b5bdd3; background:#0e1020;
    }
  </style>

  <!-- Import map for ES modules -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div class="layout">
    <aside>
      <div class="grid">
        <div class="card">
          <h2>Image (PNG → solid where black)</h2>
          <div class="img-preview">
            <canvas id="imgPreview" class="preview" width="320" height="160"></canvas>
            <div style="display:flex; flex-direction:column; gap:6px;">
              <input id="pngInput" type="file" accept="image/png,image/*" />
              <span class="badge">Tip</span>
              <span class="hint">Use a transparent/white background and black foreground for the desired solid region.</span>
            </div>
          </div>
          <div class="row">
            <label>Black Threshold</label>
            <input id="threshold" type="range" min="0" max="255" value="40" />
            <span id="thresholdVal" class="pill">40</span>
          </div>
          <div class="row">
            <label>Pixel Step</label>
            <input id="step" type="range" min="1" max="8" value="2" />
            <span id="stepVal" class="pill">2</span>
          </div>
          <div class="row">
            <label>Simplify Tolerance</label>
            <input id="simplify" type="range" min="0" max="6" step="0.1" value="1.2" />
            <span id="simplifyVal" class="pill">1.2</span>
          </div>
          <div class="row">
            <label>Smooth (Chaikin)</label>
            <input id="smooth" type="range" min="0" max="6" value="2" />
            <span id="smoothVal" class="pill">2</span>
          </div>
        </div>

        <div class="card">
          <h2>Geometry</h2>
          <div class="row">
            <label>Height</label>
            <input id="height" type="number" min="5" max="400" step="1" value="120" />
            <span class="hint">mm</span>
          </div>
          <div class="row">
            <label>Steps (Z)</label>
            <input id="steps" type="range" min="10" max="300" value="140" />
            <span id="stepsVal" class="pill">140</span>
          </div>
          <div class="row">
            <label>Curve Segments</label>
            <input id="segments" type="range" min="6" max="64" value="24" />
            <span id="segmentsVal" class="pill">24</span>
          </div>
          <div class="row">
            <label>Color</label>
            <input id="color" type="color" value="#8e77ff" />
            <span class="hint">PBR material</span>
          </div>
        </div>
        <div class="card">
        <h2>Settings</h2>
        <label class="row" style="justify-content:space-between;">
            <span>Live Bezier updates</span>
            <input id="liveBezier" type="checkbox" checked />
        </label>
        </div>
        <div class="card">
          <h2>Scale Curve (y = absolute scale)</h2>
          <div id="scaleEditor" class="editor" title="Left/drag to move • Drag handles to shape curve • Double-click empty to add • Right-click to remove"></div>
          <div class="legend"><span>z = 0</span><span>z = 1</span></div>
          <div class="two-col">
            <div class="row row-tight"><label>Y Min</label><input id="scaleYMin" type="number" step="0.1" value="0.4" /></div>
            <div class="row row-tight"><label>Y Max</label><input id="scaleYMax" type="number" step="0.1" value="2.0" /></div>
          </div>
          <div class="hint">Default anchors: (0, 1.0), (0.25, 1.1), (1.0, 1.4)</div>
        </div>

        <div class="card">
          <h2>Twist Curve (y = degrees)</h2>
          <div id="twistEditor" class="editor" title="Left/drag to move • Drag handles • Double-click empty to add • Right-click to remove"></div>
          <div class="legend"><span>z = 0</span><span>z = 1</span></div>
          <div class="two-col">
            <div class="row row-tight"><label>Deg Min</label><input id="twistYMin" type="number" step="5" value="-360" /></div>
            <div class="row row-tight"><label>Deg Max</label><input id="twistYMax" type="number" step="5" value="360" /></div>
          </div>
          <div class="row">
            <label>Twist Gain</label>
            <input id="twistGain" type="range" min="0" max="300" value="100" />
            <span id="twistGainVal" class="pill">1.00×</span>
          </div>
        </div>

        <div class="card">
          <h2>Status</h2>
          <div class="stat" id="status">Load a PNG to start.</div>
          <div class="footer-actions">
            <button id="resetView">Reset View</button>
            <button id="exportSTL" class="primary">Export STL</button>
          </div>
          <div class="env-note">Scene uses <b>RoomEnvironment</b>, PBR material, directional+hemi lights.</div>
        </div>
      </div>
    </aside>
    <div class="splitter" id="splitter" title="Drag to resize the control pane"></div>
    <main>
      <div id="viewport"></div>
    </main>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
    import { STLExporter } from 'three/addons/exporters/STLExporter.js';
    import { mergeBufferGeometries } from 'three/addons/utils/BufferGeometryUtils.js';

    // --------------------------
    // DOM refs
    // --------------------------
    const els = {
      pngInput: document.getElementById('pngInput'),
      imgPreview: document.getElementById('imgPreview'),
      threshold: document.getElementById('threshold'),
      thresholdVal: document.getElementById('thresholdVal'),
      step: document.getElementById('step'),
      stepVal: document.getElementById('stepVal'),
      simplify: document.getElementById('simplify'),
      simplifyVal: document.getElementById('simplifyVal'),
      smooth: document.getElementById('smooth'),
      smoothVal: document.getElementById('smoothVal'),
      height: document.getElementById('height'),
      steps: document.getElementById('steps'),
      stepsVal: document.getElementById('stepsVal'),
      segments: document.getElementById('segments'),
      segmentsVal: document.getElementById('segmentsVal'),
      color: document.getElementById('color'),
      scaleEditor: document.getElementById('scaleEditor'),
      twistEditor: document.getElementById('twistEditor'),
      scaleYMin: document.getElementById('scaleYMin'),
      scaleYMax: document.getElementById('scaleYMax'),
      twistYMin: document.getElementById('twistYMin'),
      twistYMax: document.getElementById('twistYMax'),
      twistGain: document.getElementById('twistGain'),
      twistGainVal: document.getElementById('twistGainVal'),
      status: document.getElementById('status'),
      resetView: document.getElementById('resetView'),
      exportSTL: document.getElementById('exportSTL'),
      viewport: document.getElementById('viewport'),
      splitter: document.getElementById('splitter'),
      liveBezier: document.getElementById('liveBezier'),
    };

    // --------------------------
    // Resizable sidebar
    // --------------------------
    (() => {



      let dragging = false, startX = 0, startW = 0;
      const onDown = (e) => {
        dragging = true; startX = e.clientX;
        const cs = getComputedStyle(document.documentElement);
        startW = parseFloat(cs.getPropertyValue('--sidebar-width'));
        document.body.style.cursor = 'col-resize';
      };
      const onMove = (e) => {
        if (!dragging) return;
        let w = startW + (e.clientX - startX);
        const min = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-min'));
        const max = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--sidebar-max'));
        w = Math.max(min, Math.min(max, w));
        document.documentElement.style.setProperty('--sidebar-width', `${w}px`);
        renderer.setSize(els.viewport.clientWidth, els.viewport.clientHeight);
      };
      const onUp = () => { dragging = false; document.body.style.cursor = 'default'; };
      els.splitter.addEventListener('pointerdown', onDown);
      window.addEventListener('pointermove', onMove);
      window.addEventListener('pointerup', onUp);
    })();

    // --------------------------
    // Three.js scene
    // --------------------------
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(els.viewport.clientWidth, els.viewport.clientHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    els.viewport.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const pmrem = new THREE.PMREMGenerator(renderer);
    scene.environment = pmrem.fromScene(new RoomEnvironment(renderer), 0.04).texture;
    scene.background = new THREE.Color(0x0b0c10);

    const camera = new THREE.PerspectiveCamera(45, els.viewport.clientWidth / els.viewport.clientHeight, 0.1, 5000);
    camera.position.set(220, 180, 220);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 60, 0);

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemi.position.set(0, 400, 0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(200, 300, 200);
    scene.add(dir);

    // Ground grid
    const grid = new THREE.PolarGridHelper(400, 16, 8, 64, 0x2a2d38, 0x23263a);
    grid.position.y = 0;
    scene.add(grid);

    // Mesh/material holders
    let currentMesh = null;
    let baseGeometryPositions = null; // Float32Array copy of untwisted/unscaled geometry positions

    const material = new THREE.MeshPhysicalMaterial({
      color: new THREE.Color(els.color.value),
      metalness: 0.05,
      roughness: 0.6,
      clearcoat: 0.05,
      transmission: 0.0,
      envMapIntensity: 0.9
    });

    // --------------------------
    // Render loop
    // --------------------------
    function render(){
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }
    render();

    window.addEventListener('resize', () => {
      camera.aspect = els.viewport.clientWidth / els.viewport.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(els.viewport.clientWidth, els.viewport.clientHeight);
    });

    // --------------------------
    // PNG handling & vectorization
    // --------------------------
    const imgCanvas = document.createElement('canvas');
    const imgCtx = imgCanvas.getContext('2d', { willReadFrequently: true });

    function drawPreview(image) {
      const ctx = els.imgPreview.getContext('2d');
      ctx.clearRect(0,0,els.imgPreview.width, els.imgPreview.height);
      const scale = Math.min(els.imgPreview.width / image.width, els.imgPreview.height / image.height);
      const w = Math.floor(image.width * scale);
      const h = Math.floor(image.height * scale);
      const x = Math.floor((els.imgPreview.width - w) / 2);
      const y = Math.floor((els.imgPreview.height - h) / 2);
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(image, x, y, w, h);
      ctx.strokeStyle = '#2b2e44';
      ctx.strokeRect(0.5, 0.5, els.imgPreview.width-1, els.imgPreview.height-1);
    }

    function loadImageFromFile(file){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
      });
    }

    function imageToBinaryGrid(image, threshold = 40, step = 2){
      // Draw at native size
      imgCanvas.width = image.width;
      imgCanvas.height = image.height;
      imgCtx.clearRect(0,0,image.width,image.height);
      imgCtx.drawImage(image, 0, 0);
      const data = imgCtx.getImageData(0,0,image.width,image.height).data;

      // Downsample with `step` for performance; still examine per-pixel thresholding
      const W = Math.floor(image.width / step);
      const H = Math.floor(image.height / step);
      const grid = new Uint8Array(W * H);

      for (let y = 0; y < H; y++){
        for (let x = 0; x < W; x++){
          const sx = x * step;
          const sy = y * step;
          const idx = (sy * image.width + sx) * 4;
          const r = data[idx], g = data[idx+1], b = data[idx+2], a = data[idx+3];
          const lum = 0.2126*r + 0.7152*g + 0.0722*b;
          // Consider alpha; transparent counts as background (white)
          const isBlack = (a > 10) && (lum < threshold);
          grid[y * W + x] = isBlack ? 1 : 0;
        }
      }
      return { grid, W, H, step };
    }

    // Marching Squares contour extraction → segments → polylines
    function extractContoursMS(binary, W, H){
      // Values are 0 or 1. We compute edges between inside (1) and outside (0) at iso=0.5
      const segs = [];
      // helper to add segment
      const addSeg = (ax, ay, bx, by) => { segs.push({ ax, ay, bx, by }); };

      // For each cell
      for (let y = 0; y < H - 1; y++){
        for (let x = 0; x < W - 1; x++){
          const p0 = binary[y*W + x];
          const p1 = binary[y*W + (x+1)];
          const p2 = binary[(y+1)*W + (x+1)];
          const p3 = binary[(y+1)*W + x];
          const idx = (p0?1:0) | ((p1?1:0)<<1) | ((p2?1:0)<<2) | ((p3?1:0)<<3);
          if (idx === 0 || idx === 15) continue;

          // Midpoints on edges (placed at half grid)
          const xm = x + 0.5, ym = y + 0.5;
          const left   = { x,     y: ym };
          const right  = { x: x+1, y: ym };
          const top    = { x: xm, y };
          const bottom = { x: xm, y: y+1 };

          // Resolve ambiguous 5 & 10 using average (asymmetric to favor inside continuity)
          switch(idx){
            case 1: case 14: addSeg(left.x, left.y, top.x, top.y); break;
            case 2: case 13: addSeg(top.x, top.y, right.x, right.y); break;
            case 3: case 12: addSeg(left.x, left.y, right.x, right.y); break;
            case 4: case 11: addSeg(right.x, right.y, bottom.x, bottom.y); break;
            case 5:
              if (p0 + p1 + p2 + p3 >= 2) { addSeg(top.x, top.y, right.x, right.y); addSeg(left.x, left.y, bottom.x, bottom.y); }
              else { addSeg(left.x, left.y, top.x, top.y); addSeg(bottom.x, bottom.y, right.x, right.y); }
              break;
            case 6: case 9:  addSeg(top.x, top.y, bottom.x, bottom.y); break;
            case 7: case 8:  addSeg(left.x, left.y, bottom.x, bottom.y); break;
            case 10:
              if (p0 + p1 + p2 + p3 >= 2) { addSeg(left.x, left.y, top.x, top.y); addSeg(bottom.x, bottom.y, right.x, right.y); }
              else { addSeg(top.x, top.y, right.x, right.y); addSeg(left.x, left.y, bottom.x, bottom.y); }
              break;
          }
        }
      }

      // Chain segments into closed polylines
      const key = (x,y) => `${x.toFixed(3)},${y.toFixed(3)}`;
      const map = new Map();
      for (const s of segs){
        const a = key(s.ax, s.ay), b = key(s.bx, s.by);
        if (!map.has(a)) map.set(a, []);
        if (!map.has(b)) map.set(b, []);
        map.get(a).push({ x: s.bx, y: s.by, key: b });
        map.get(b).push({ x: s.ax, y: s.ay, key: a });
      }

      const used = new Set();
      const loops = [];
      for (const s of segs){
        const k0 = key(s.ax, s.ay), k1 = key(s.bx, s.by);
        const edgeId = `${k0}->${k1}`;
        const edgeIdR = `${k1}->${k0}`;
        if (used.has(edgeId) || used.has(edgeIdR)) continue;

        // Start new loop
        const loop = [{ x: s.ax, y: s.ay }];
        let cur = { x: s.bx, y: s.by }, prevKey = k0;
        used.add(edgeId); used.add(edgeIdR);
        while (true){
          loop.push(cur);
          const neighbors = map.get(key(cur.x, cur.y));
          if (!neighbors || neighbors.length === 0) break;
          // choose neighbor that's not the previous node
          const next = neighbors.find(n => key(n.x,n.y) !== prevKey);
          if (!next) break;
          const e0 = `${key(cur.x,cur.y)}->${key(next.x,next.y)}`;
          const e1 = `${key(next.x,next.y)}->${key(cur.x,cur.y)}`;
          if (used.has(e0) || used.has(e1)) break;
          used.add(e0); used.add(e1);
          prevKey = key(cur.x, cur.y);
          cur = { x: next.x, y: next.y };
          if (Math.hypot(loop[0].x - cur.x, loop[0].y - cur.y) < 1e-6) {
            // closed
            break;
          }
        }
        if (loop.length >= 3) loops.push(loop);
      }
      return loops;
    }

    // Douglas-Peucker simplification
    function simplifyDP(points, tol){
      if (tol <= 0 || points.length < 3) return points.slice();
      const sqTol = tol*tol;
      const newPts = [points[0]];
      function sqDist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }
      function sqSegDist(p,a,b){
        let x=a.x, y=a.y; let dx=b.x-x, dy=b.y-y;
        if (dx!==0 || dy!==0){
          const t = ((p.x-x)*dx+(p.y-y)*dy)/(dx*dx+dy*dy);
          if (t>1){ x=b.x; y=b.y; }
          else if (t>0){ x+=dx*t; y+=dy*t; }
        }
        dx=p.x-x; dy=p.y-y; return dx*dx+dy*dy;
      }
      function simplifyDPStep(pts, first, last, sqTol, out){
        let maxDist = sqTol, index = -1;
        for (let i=first+1; i<last; i++){
          const dist = sqSegDist(pts[i], pts[first], pts[last]);
          if (dist > maxDist){ index=i; maxDist=dist; }
        }
        if (index >= 0){
          if (index-first > 1) simplifyDPStep(pts, first, index, sqTol, out);
          out.push(pts[index]);
          if (last-index > 1) simplifyDPStep(pts, index, last, sqTol, out);
        }
      }
      const out = [];
      simplifyDPStep(points, 0, points.length - 1, sqTol, out);
      newPts.push(...out, points[points.length-1]);
      return newPts;
    }

    // Chaikin smoothing (round corners)
    function chaikin(points, iterations=1){
      let pts = points;
      for (let k=0; k<iterations; k++){
        const res = [];
        for (let i=0; i<pts.length; i++){
          const p0 = pts[i];
          const p1 = pts[(i+1)%pts.length];
          const Q = { x: 0.75*p0.x + 0.25*p1.x, y: 0.75*p0.y + 0.25*p1.y };
          const R = { x: 0.25*p0.x + 0.75*p1.x, y: 0.25*p0.y + 0.75*p1.y };
          res.push(Q, R);
        }
        pts = res;
      }
      return pts;
    }

    // Polygon area and point-in-polygon
    function ringArea(ring){
      let a=0; for (let i=0, n=ring.length; i<n; i++){
        const p=ring[i], q=ring[(i+1)%n]; a += p.x*q.y - q.x*p.y;
      } return 0.5*a;
    }
    function pointInPoly(pt, poly){
      let c = false;
      for (let i=0, j=poly.length-1; i<poly.length; j=i++){
        const pi=poly[i], pj=poly[j];
        if (((pi.y>pt.y)!==(pj.y>pt.y)) && (pt.x < (pj.x-pi.x)*(pt.y-pi.y)/(pj.y-pi.y)+pi.x)) c=!c;
      }
      return c;
    }

    function buildShapesFromLoops(loops, scaleToMM = 1.0, center=true){
      if (!loops.length) return [];
      // scale grid coordinates to mm and center around origin
      // First, gather bounds
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      for (const loop of loops){
        for (const p of loop){
          if (p.x<minX) minX=p.x; if (p.x>maxX) maxX=p.x;
          if (p.y<minY) minY=p.y; if (p.y>maxY) maxY=p.y;
        }
      }
      const cx = (minX+maxX)/2, cy = (minY+maxY)/2;

      // Transform loops to mm coordinates with origin centered
      const loopsMM = loops.map(loop =>
        loop.map(p => ({ x: (p.x - cx) * scaleToMM, y: (p.y - cy) * scaleToMM }))
      );

      // Classify rings into hierarchy: outer (CCW area>0) and holes inside them
      const rings = loopsMM.map(r => ({ ring:r, area: ringArea(r) }));
      // Sort by absolute area descending to determine containment easily
      rings.sort((a,b)=>Math.abs(b.area)-Math.abs(a.area));

      const outers = [];
      const children = new Map();
      for (let i=0; i<rings.length; i++){
        children.set(i, []);
      }

      const parents = new Array(rings.length).fill(-1);
      for (let i=0; i<rings.length; i++){
        let parent = -1;
        for (let j=0; j<i; j++){
          // if ring i inside ring j?
          if (pointInPoly(rings[i].ring[0], rings[j].ring)){
            parent = j; break;
          }
        }
        parents[i] = parent;
        if (parent === -1) outers.push(i);
        else children.get(parent).push(i);
      }

      // Build THREE.Shape for each outer, attach immediate children as holes if alternating parity requires it
      const shapes = [];
      for (const oi of outers){
        const outer = rings[oi].ring;
        const shape = new THREE.Shape(outer.map(p => new THREE.Vector2(p.x, p.y)));
        // holes: children at odd-depth
        const holes = children.get(oi) || [];
        for (const hi of holes){
          // treat it as a hole (reverse orientation for Three.js if needed)
          let hole = rings[hi].ring.slice().reverse();
          shape.holes.push(new THREE.Path(hole.map(p => new THREE.Vector2(p.x, p.y))));
        }
        shapes.push(shape);
      }
      return shapes;
    }

    // --------------------------
    // Curve Editor (Bezier with draggable handles)
    // --------------------------
    class BezierEditor {
      /**
       * @param {HTMLElement} container
       * @param {{yMin:number, yMax:number, initial:Array, onCommit:Function, onInput?:Function}} opts
       * initial: [{x:0..1, y: number, hr:{x,y}, hl:{x,y}}...]; handles are offsets
       */
      constructor(container, opts){
        this.el = container;
        this.canvas = document.createElement('canvas');
        this.canvas.width = container.clientWidth;
        this.canvas.height = container.clientHeight;
        this.ctx = this.canvas.getContext('2d');
        this.yMin = opts.yMin; this.yMax = opts.yMax;
        this.onCommit = opts.onCommit;
        this.onInput = opts.onInput || null;

        this.points = (opts.initial || [
          { x:0.00, y:1.0, hr:{x: 0.10, y: 0}, hl:{x:-0.10, y: 0} },
          { x:0.25, y:1.1, hr:{x: 0.10, y: 0}, hl:{x:-0.10, y: 0} },
          { x:1.00, y:1.4, hr:{x: 0.10, y: 0}, hl:{x:-0.10, y: 0} },
        ]).map(p => ({...p, hr:{...p.hr}, hl:{...p.hl}}));

        // Interaction state
        this.drag = null; // { type: 'p'|'hr'|'hl', index, dx, dy }
        this.hover = null;
        this.pixelRatio = Math.min(window.devicePixelRatio || 1, 2);

        container.appendChild(this.canvas);
        // Resize observer
        new ResizeObserver(()=>this.resize()).observe(container);
        this.bind();
        this.draw();
      }
      setYRange(min, max){ this.yMin=min; this.yMax=max; this.draw(); if (this.onCommit) this.onCommit(); }

      resize(){
        const w = this.el.clientWidth, h = this.el.clientHeight;
        this.canvas.width = Math.max(10, Math.floor(w * this.pixelRatio));
        this.canvas.height = Math.max(10, Math.floor(h * this.pixelRatio));
        this.canvas.style.width = w + 'px';
        this.canvas.style.height = h + 'px';
        this.draw();
      }
      xToPx(x){ return x * this.canvas.width; }
      yToPx(y){
        // map yMin..yMax to bottom..top
        const t = (y - this.yMin) / (this.yMax - this.yMin);
        return (1 - t) * this.canvas.height;
      }
      pxToX(px){ return px / this.canvas.width; }
      pxToY(py){
        const t = 1 - (py / this.canvas.height);
        return this.yMin + t * (this.yMax - this.yMin);
      }
      screenPts(){
        return this.points.map(p => ({
          p: { x: this.xToPx(p.x), y: this.yToPx(p.y) },
          hr: { x: this.xToPx(p.x + p.hr.x), y: this.yToPx(p.y + p.hr.y) },
          hl: { x: this.xToPx(p.x + p.hl.x), y: this.yToPx(p.y + p.hl.y) },
        }));
      }
      draw(){
        const ctx = this.ctx;
        ctx.clearRect(0,0,this.canvas.width, this.canvas.height);

        // grid
        ctx.save();
        ctx.strokeStyle = '#23263a';
        ctx.lineWidth = 1 * this.pixelRatio;
        const gx = 10, gy = 6;
        for (let i=1;i<gx;i++){
          const x = i * this.canvas.width / gx;
          ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,this.canvas.height); ctx.stroke();
        }
        for (let j=1;j<gy;j++){
          const y = j * this.canvas.height / gy;
          ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(this.canvas.width,y); ctx.stroke();
        }
        ctx.restore();

        // sort points by x
        this.points.sort((a,b)=>a.x - b.x);

        // curve
        const sp = this.screenPts();
        ctx.save();
        ctx.lineWidth = 2 * this.pixelRatio;
        ctx.strokeStyle = '#7c3aed';
        ctx.beginPath();
        for (let i=0; i<sp.length-1; i++){
          const a = sp[i], b = sp[i+1];
          ctx.moveTo(a.p.x, a.p.y);
          ctx.bezierCurveTo(a.hr.x, a.hr.y, b.hl.x, b.hl.y, b.p.x, b.p.y);
        }
        ctx.stroke();
        ctx.restore();

        // handles
        ctx.save();
        ctx.lineWidth = 1 * this.pixelRatio;
        for (let i=0;i<sp.length;i++){
          const s = sp[i];
          ctx.strokeStyle = '#3a3f5f';
          ctx.beginPath(); ctx.moveTo(s.p.x, s.p.y); ctx.lineTo(s.hr.x, s.hr.y); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(s.p.x, s.p.y); ctx.lineTo(s.hl.x, s.hl.y); ctx.stroke();
          // handle points
          ctx.fillStyle = '#2c2f45';
          ctx.strokeStyle = '#4a4f70';
          ctx.beginPath(); ctx.arc(s.hr.x, s.hr.y, 5*this.pixelRatio, 0, Math.PI*2); ctx.fill(); ctx.stroke();
          ctx.beginPath(); ctx.arc(s.hl.x, s.hl.y, 5*this.pixelRatio, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        }
        ctx.restore();

        // anchor points
        ctx.save();
        for (let i=0;i<sp.length;i++){
          const s = sp[i];
          ctx.fillStyle = '#10121c';
          ctx.strokeStyle = '#b0b4d0';
          ctx.lineWidth = 2 * this.pixelRatio;
          ctx.beginPath(); ctx.arc(s.p.x, s.p.y, 6*this.pixelRatio, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        }
        ctx.restore();
      }

      // Evaluate y at normalized x in [0,1] using cubic Bezier segments.
      // We force param u = normalized between consecutive points; handles x affect slope weighting slightly.
      valueAt(t){
        const pts = this.points;
        if (pts.length === 0) return 1.0;
        if (t <= pts[0].x) return pts[0].y;
        if (t >= pts[pts.length-1].x) return pts[pts.length-1].y;

        // find segment
        let i = 0;
        for (; i<pts.length-1; i++){
          if (t >= pts[i].x && t <= pts[i+1].x) break;
        }
        const a = pts[i], b = pts[i+1];
        const span = (b.x - a.x) || 1e-6;
        const u = (t - a.x) / span;

        // Control points in Y. We use handle X as a tension scaler to approximate slope control.
        const tensionA = Math.max(0.05, Math.abs(a.hr.x)) / 0.25; // normalized ~ around default 0.10
        const tensionB = Math.max(0.05, Math.abs(b.hl.x)) / 0.25;

        const y0 = a.y;
        const y1 = a.y + a.hr.y * (0.8 * tensionA);
        const y2 = b.y + b.hl.y * (0.8 * tensionB);
        const y3 = b.y;

        // Cubic Bezier in Y with parameter u
        const uu = 1-u;
        return uu*uu*uu*y0 + 3*uu*uu*u*y1 + 3*uu*u*u*y2 + u*u*u*y3;
      }

      bind(){
        const pickRadius = 10;
        const findHit = (px, py) => {
          const sp = this.screenPts();
          // prefer anchor/handle under pointer; do not create new node if one is near
          for (let i=0;i<sp.length;i++){
            const s = sp[i];
            if (Math.hypot(px - s.p.x, py - s.p.y) <= pickRadius*this.pixelRatio) return { type:'p', index:i };
            if (Math.hypot(px - s.hr.x, py - s.hr.y) <= pickRadius*this.pixelRatio) return { type:'hr', index:i };
            if (Math.hypot(px - s.hl.x, py - s.hl.y) <= pickRadius*this.pixelRatio) return { type:'hl', index:i };
          }
          return null;
        };

        const onPointerDown = (e) => {
          const rect = this.canvas.getBoundingClientRect();
          const px = (e.clientX - rect.left) * this.pixelRatio;
          const py = (e.clientY - rect.top) * this.pixelRatio;

          const hit = findHit(px, py);
          if (hit){
            this.drag = { ...hit, startX: px, startY: py };
            return;
          }
          if (e.button === 0){
            // only add if no nearby node (important!)
            // add point at curve value
            const nx = this.pxToX(px);
            const ny = this.valueAt(nx);
            const idx = this.points.findIndex(p => p.x > nx);
            const newP = { x:nx, y:ny, hr:{x:0.1, y:0}, hl:{x:-0.1, y:0} };
            if (idx === -1) this.points.push(newP);
            else this.points.splice(idx, 0, newP);
            this.draw();
            // do not start drag automatically to avoid accidental duplicate creation
          }
        };
        const onPointerMove = (e) => {
          if (!this.drag) return;
          const rect = this.canvas.getBoundingClientRect();
          const px = (e.clientX - rect.left) * this.pixelRatio;
          const py = (e.clientY - rect.top) * this.pixelRatio;
          const dx = px - this.drag.startX;
          const dy = py - this.drag.startY;
          this.drag.startX = px; this.drag.startY = py;

          const p = this.points[this.drag.index];
          if (!p) return;
          if (this.drag.type === 'p'){
            // move anchor (clamp x to [0,1]; y to [yMin,yMax])
            const nx = this.pxToX(this.xToPx(p.x) + dx);
            const ny = this.pxToY(this.yToPx(p.y) + dy);
            p.x = Math.min(1, Math.max(0, nx));
            p.y = Math.min(this.yMax, Math.max(this.yMin, ny));
            // keep handles relative
          } else if (this.drag.type === 'hr'){
            const h = { x: this.xToPx(p.x + p.hr.x) + dx, y: this.yToPx(p.y + p.hr.y) + dy };
            p.hr.x = this.pxToX(h.x) - p.x;
            p.hr.y = this.pxToY(h.y) - p.y;
          } else if (this.drag.type === 'hl'){
            const h = { x: this.xToPx(p.x + p.hl.x) + dx, y: this.yToPx(p.y + p.hl.y) + dy };
            p.hl.x = this.pxToX(h.x) - p.x;
            p.hl.y = this.pxToY(h.y) - p.y;
          }
          this.draw();
          if (this.onInput) this.onInput();
        };
        const onPointerUp = () => {
          if (this.drag && this.onCommit) this.onCommit();
          this.drag = null;
        };
        const onContextMenu = (e) => {
          e.preventDefault();
          const rect = this.canvas.getBoundingClientRect();
          const px = (e.clientX - rect.left) * this.pixelRatio;
          const py = (e.clientY - rect.top) * this.pixelRatio;
          const sp = this.screenPts();
          for (let i=0;i<sp.length;i++){
            if (Math.hypot(px - sp[i].p.x, py - sp[i].p.y) <= 10*this.pixelRatio){
              if (this.points.length > 2){
                this.points.splice(i,1);
                this.draw();
                if (this.onCommit) this.onCommit();
              }
              break;
            }
          }
        };

        this.canvas.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('pointermove', onPointerMove);
        window.addEventListener('pointerup', onPointerUp);
        this.canvas.addEventListener('contextmenu', onContextMenu);
      }
    }
    let _raf = 0;
        const liveApply = () => {
        if (_raf) return;
        _raf = requestAnimationFrame(() => { _raf = 0; applyDeformation(); });
      };
    // Instantiate editors
    const scaleEditor = new BezierEditor(els.scaleEditor, {
      yMin: parseFloat(els.scaleYMin.value),
      yMax: parseFloat(els.scaleYMax.value),
      initial: [
        { x:0.00, y:1.0, hr:{x: 0.10, y: 0}, hl:{x:-0.10, y: 0} },
        { x:0.25, y:1.1, hr:{x: 0.10, y: 0}, hl:{x:-0.10, y: 0} },
        { x:1.00, y:1.4, hr:{x: 0.10, y: 0}, hl:{x:-0.10, y: 0} },
      ],
    onCommit: () => applyDeformation(),
    onInput: els.liveBezier.checked ? liveApply : null
    });


    const twistEditor = new BezierEditor(els.twistEditor, {
      yMin: parseFloat(els.twistYMin.value),
      yMax: parseFloat(els.twistYMax.value),
      initial: [
        { x:0.00, y:0, hr:{x: 0.10, y: 0}, hl:{x:-0.10, y: 0} },
        { x:1.00, y:180, hr:{x: 0.10, y: 0}, hl:{x:-0.10, y: 0} },
      ],
      onCommit: () => applyDeformation(),
      onInput: els.liveBezier.checked ? liveApply : null
    });

    // Allow dynamic Y ranges
    els.scaleYMin.addEventListener('change', ()=> scaleEditor.setYRange(parseFloat(els.scaleYMin.value), parseFloat(els.scaleYMax.value)));
    els.scaleYMax.addEventListener('change', ()=> scaleEditor.setYRange(parseFloat(els.scaleYMin.value), parseFloat(els.scaleYMax.value)));
    els.twistYMin.addEventListener('change', ()=> twistEditor.setYRange(parseFloat(els.twistYMin.value), parseFloat(els.twistYMax.value)));
    els.twistYMax.addEventListener('change', ()=> twistEditor.setYRange(parseFloat(els.twistYMin.value), parseFloat(els.twistYMax.value)));
    els.liveBezier.addEventListener('change', () => {const cb = els.liveBezier.checked ? liveApply : null; scaleEditor.onInput = cb; twistEditor.onInput = cb;});

    // --------------------------
    // Geometry building
    // --------------------------
    function buildGeometryFromPNG(image){
      const threshold = parseInt(els.threshold.value, 10);
      const step = parseInt(els.step.value, 10);
      const simplifyTol = parseFloat(els.simplify.value);
      const smoothIter = parseInt(els.smooth.value, 10);

      const { grid:bin, W, H } = imageToBinaryGrid(image, threshold, step);
      const loops = extractContoursMS(bin, W, H);
      if (!loops.length){
        setStatus('No solid region detected (adjust threshold).', 'warn');
        return null;
      }

      // Simplify + smooth each loop
      const simplified = loops.map(loop => {
        const L = loop.length;
        const closed = loop[0].x === loop[L-1]?.x && loop[0].y === loop[L-1]?.y;
        const pts = closed ? loop.slice(0, L-1) : loop.slice(0);
        const simp = simplifyDP(pts, simplifyTol);
        const sm = smoothIter > 0 ? chaikin(simp, smoothIter) : simp;
        return sm;
      });

      // Build THREE.Shape(s); scale grid units to mm: assume 1 sample pixel = 1 mm for now (you can change scale here)
      const pixelToMM = 1.0;
      const shapes = buildShapesFromLoops(simplified, pixelToMM, true);
      if (!shapes.length){
        setStatus('Vectorization produced no shapes.', 'warn');
        return null;
      }

      // Build ExtrudeGeometry (solid) with steps along Z
      const heightMM = parseFloat(els.height.value);
      const steps = parseInt(els.steps.value, 10);
      const curveSegments = parseInt(els.segments.value, 10);

      const extrudeSettings = {
        steps,
        depth: heightMM,
        bevelEnabled: false,
        curveSegments
      };

      const geoms = shapes.map(s => new THREE.ExtrudeGeometry(s, extrudeSettings));
let geom = geoms.length > 1 ? mergeBufferGeometries(geoms, false) : geoms[0];
if (!geom) geom = geoms[0]; // super-safety
if (geoms.length > 1) geoms.forEach(g => g.dispose());
      if (!geom) return null;

      // Center geometry around Z axis (x,y already centered via shapes)
      geom.computeBoundingBox();
      const bb = geom.boundingBox;
      const shift = new THREE.Vector3(
        (bb.min.x + bb.max.x)/2,
        (bb.min.y + bb.max.y)/2,
        0
      );
      geom.translate(-shift.x, -shift.y, 0);

      // Save base positions for deformation
      baseGeometryPositions = geom.attributes.position.array.slice(0);

      return geom;
    }

    // Apply scale & twist fields to the current geometry positions, using the saved base positions
    function applyDeformation(){
      if (!currentMesh || !baseGeometryPositions) return;
      const geom = currentMesh.geometry;
      const pos = geom.attributes.position.array;
      const heightMM = parseFloat(els.height.value);

      const scaleAt = (zNorm) => Math.max(0.01, scaleEditor.valueAt(zNorm));
      const twistGain = parseInt(els.twistGain.value, 10) / 100.0;
      const twistAt = (zNorm) => (twistEditor.valueAt(zNorm) * twistGain) * Math.PI / 180.0;

      // compute centroid X,Y (already centered, so 0,0)
      const cx = 0, cy = 0;

      for (let i=0; i<pos.length; i+=3){
        const bx = baseGeometryPositions[i];
        const by = baseGeometryPositions[i+1];
        const bz = baseGeometryPositions[i+2];

        const zNorm = Math.min(1, Math.max(0, bz / heightMM));

        const s = scaleAt(zNorm);
        const ang = twistAt(zNorm);

        // scale about center, then rotate around Z
        const sx = (bx - cx) * s;
        const sy = (by - cy) * s;

        const cos = Math.cos(ang), sin = Math.sin(ang);
        const rx = sx * cos - sy * sin;
        const ry = sx * sin + sy * cos;

        pos[i]   = rx + cx;
        pos[i+1] = ry + cy;
        // z unchanged
      }
      geom.attributes.position.needsUpdate = true;
      geom.computeVertexNormals();
      geom.computeBoundingBox();
      fitCameraToObject(currentMesh, 1.25);
      updateStatusGeom(geom);
    }

    function setStatus(msg, level='info'){
      const color = level==='info' ? 'var(--text)' : level==='warn' ? 'var(--warn)' : level==='bad' ? 'var(--bad)' : 'var(--text)';
      els.status.innerHTML = `<span style="color:${color}">${msg}</span>`;
    }
    function updateStatusGeom(geom){
      const vcount = geom.attributes.position.count;
      const tricount = geom.index ? geom.index.count/3 : vcount/3;
      const bb = geom.boundingBox;
      const size = new THREE.Vector3(); bb.getSize(size);
      els.status.innerHTML =
        `Verts: <b>${vcount.toLocaleString()}</b> &nbsp; | &nbsp; Tris: <b>${Math.floor(tricount).toLocaleString()}</b> &nbsp; | &nbsp; Size: <b>${size.x.toFixed(1)}×${size.y.toFixed(1)}×${size.z.toFixed(1)} mm</b>`;
    }

    // Fit camera
    function fitCameraToObject(object, zoom = 1.2){
      const box = new THREE.Box3().setFromObject(object);
      const size = new THREE.Vector3();
      const center = new THREE.Vector3();
      box.getSize(size);
      box.getCenter(center);

      const maxSize = Math.max(size.x, size.y, size.z);
      const fitHeightDistance = maxSize / (2 * Math.atan((Math.PI * camera.fov / 180) / 2));
      const fitWidthDistance = fitHeightDistance / camera.aspect;
      const distance = zoom * Math.max(fitHeightDistance, fitWidthDistance);

      const dir = controls.target.clone()
        .sub(camera.position)
        .normalize()
        .multiplyScalar(-1);

      controls.target.copy(center);
      camera.position.copy(center).add(new THREE.Vector3(distance, distance * 0.8, distance));
      camera.near = distance / 100;
      camera.far = distance * 100;
      camera.updateProjectionMatrix();
      controls.update();
    }

    // --------------------------
    // UI events
    // --------------------------
    els.threshold.addEventListener('input', () => { els.thresholdVal.textContent = els.threshold.value; tryRebuildFromImage(); });
    els.step.addEventListener('input', () => { els.stepVal.textContent = els.step.value; tryRebuildFromImage(); });
    els.simplify.addEventListener('input', () => { els.simplifyVal.textContent = els.simplify.value; tryRebuildFromImage(); });
    els.smooth.addEventListener('input', () => { els.smoothVal.textContent = els.smooth.value; tryRebuildFromImage(); });

    els.height.addEventListener('change', () => tryRebuildFromImage());
    els.steps.addEventListener('input', () => { els.stepsVal.textContent = els.steps.value; tryRebuildFromImage(); });
    els.segments.addEventListener('input', () => { els.segmentsVal.textContent = els.segments.value; tryRebuildFromImage(); });

    els.color.addEventListener('input', () => { material.color.set(els.color.value); });

    els.twistGain.addEventListener('input', () => {
      els.twistGainVal.textContent = (parseInt(els.twistGain.value,10)/100).toFixed(2) + '×';
    });
    els.twistGain.addEventListener('change', () => applyDeformation());

    let currentImage = null;
    els.pngInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const img = await loadImageFromFile(file);
      currentImage = img;
      drawPreview(img);
      rebuildAll();
    });

    els.resetView.addEventListener('click', () => { if (currentMesh) fitCameraToObject(currentMesh, 1.2); });

    els.exportSTL.addEventListener('click', () => {
      if (!currentMesh){
        setStatus('Nothing to export. Load an image first.', 'warn');
        return;
      }
      const exporter = new STLExporter();
      const data = exporter.parse(currentMesh, { binary: true });
      const blob = new Blob([data], { type: 'application/octet-stream' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      const ts = new Date().toISOString().replace(/[:.]/g,'-');
      a.download = `vase-${ts}.stl`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    // Debounced rebuild helpers
    let rebuildRAF = 0;
    function tryRebuildFromImage(){
      if (!currentImage) return;
      cancelAnimationFrame(rebuildRAF);
      rebuildRAF = requestAnimationFrame(rebuildAll);
    }

    function rebuildAll(){
      if (!currentImage) { setStatus('Load a PNG to start.', 'info'); return; }

      // Remove previous mesh
      if (currentMesh){
        scene.remove(currentMesh);
        currentMesh.geometry.dispose();
        currentMesh = null;
      }

      const geom = buildGeometryFromPNG(currentImage);
      if (!geom){
        setStatus('Failed to build geometry.', 'bad');
        return;
      }

    currentMesh = new THREE.Mesh(geom, material);
    // stand the extruded Z-axis up along +Y
    currentMesh.rotation.x = -Math.PI / 2;

    currentMesh.castShadow = false;
    currentMesh.receiveShadow = false;
    scene.add(currentMesh);

      // Save base positions AFTER extrude, BEFORE twist/scale
      baseGeometryPositions = geom.attributes.position.array.slice(0);

      // Apply deformation fields once
      applyDeformation();

      fitCameraToObject(currentMesh, 1.25);
      updateStatusGeom(geom);
    }

    // Kick things off with a tiny default image (circle) so viewport shows something
    (function bootstrap(){
      const temp = document.createElement('canvas');
      temp.width = 256; temp.height = 256;
      const ctx = temp.getContext('2d');
      ctx.fillStyle = '#fff'; ctx.fillRect(0,0,256,256);
      ctx.fillStyle = '#000';
      ctx.beginPath(); ctx.arc(128,128,90,0,Math.PI*2); ctx.fill();
      const img = new Image();
      img.onload = () => {
        currentImage = img;
        drawPreview(img);
        rebuildAll();
      };
      img.src = temp.toDataURL('image/png');
    })();

    // --------------------------
    // BufferGeometryUtils fallback (merge) — tiny inlined subset if needed
    // --------------------------
    // If you want multi-shape merging, import 'three/addons/utils/BufferGeometryUtils.js'
    // For now, we rely on first shape only (works well for common cases).
  </script>
</body>
</html>
